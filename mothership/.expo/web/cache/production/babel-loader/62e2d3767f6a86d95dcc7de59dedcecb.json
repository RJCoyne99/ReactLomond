{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{PermissionStatus,createPermissionHook,EventEmitter,Platform}from'expo-modules-core';import{_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS}from\"../AV\";import ExponentAV from\"../ExponentAV\";import{isAudioEnabled,throwIfAudioIsDisabled}from\"./AudioAvailability\";import{RECORDING_OPTIONS_PRESET_LOW_QUALITY}from\"./RecordingConstants\";import{Sound}from\"./Sound\";var _recorderExists=false;var eventEmitter=Platform.OS==='android'?new EventEmitter(ExponentAV):null;export function getPermissionsAsync(){return _regeneratorRuntime.async(function getPermissionsAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:return _context.abrupt(\"return\",ExponentAV.getPermissionsAsync());case 1:case\"end\":return _context.stop();}}},null,null,null,Promise);}export function requestPermissionsAsync(){return _regeneratorRuntime.async(function requestPermissionsAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:return _context2.abrupt(\"return\",ExponentAV.requestPermissionsAsync());case 1:case\"end\":return _context2.stop();}}},null,null,null,Promise);}export var usePermissions=createPermissionHook({getMethod:getPermissionsAsync,requestMethod:requestPermissionsAsync});export var Recording=function(){function Recording(){var _this=this;_classCallCheck(this,Recording);this._subscription=null;this._canRecord=false;this._isDoneRecording=false;this._finalDurationMillis=0;this._uri=null;this._onRecordingStatusUpdate=null;this._progressUpdateTimeoutVariable=null;this._progressUpdateIntervalMillis=_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;this._options=null;this._cleanupForUnloadedRecorder=function _callee(finalStatus){var _finalStatus$duration;return _regeneratorRuntime.async(function _callee$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_this._canRecord=false;_this._isDoneRecording=true;_this._finalDurationMillis=(_finalStatus$duration=finalStatus==null?void 0:finalStatus.durationMillis)!=null?_finalStatus$duration:0;_recorderExists=false;if(_this._subscription){_this._subscription.remove();_this._subscription=null;}_this._disablePolling();_context3.next=8;return _regeneratorRuntime.awrap(_this.getStatusAsync());case 8:return _context3.abrupt(\"return\",_context3.sent);case 9:case\"end\":return _context3.stop();}}},null,null,null,Promise);};this._pollingLoop=function _callee2(){return _regeneratorRuntime.async(function _callee2$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(!(isAudioEnabled()&&_this._canRecord&&_this._onRecordingStatusUpdate!=null)){_context4.next=10;break;}_this._progressUpdateTimeoutVariable=setTimeout(_this._pollingLoop,_this._progressUpdateIntervalMillis);_context4.prev=2;_context4.next=5;return _regeneratorRuntime.awrap(_this.getStatusAsync());case 5:_context4.next=10;break;case 7:_context4.prev=7;_context4.t0=_context4[\"catch\"](2);_this._disablePolling();case 10:case\"end\":return _context4.stop();}}},null,null,[[2,7]],Promise);};this.getStatusAsync=function _callee3(){var status;return _regeneratorRuntime.async(function _callee3$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:if(!_this._canRecord){_context5.next=2;break;}return _context5.abrupt(\"return\",_this._performOperationAndHandleStatusAsync(function(){return ExponentAV.getAudioRecordingStatus();}));case 2:status={canRecord:false,isRecording:false,isDoneRecording:_this._isDoneRecording,durationMillis:_this._finalDurationMillis};_this._callOnRecordingStatusUpdateForNewStatus(status);return _context5.abrupt(\"return\",status);case 5:case\"end\":return _context5.stop();}}},null,null,null,Promise);};}_createClass(Recording,[{key:\"_disablePolling\",value:function _disablePolling(){if(this._progressUpdateTimeoutVariable!=null){clearTimeout(this._progressUpdateTimeoutVariable);this._progressUpdateTimeoutVariable=null;}}},{key:\"_enablePollingIfNecessaryAndPossible\",value:function _enablePollingIfNecessaryAndPossible(){if(isAudioEnabled()&&this._canRecord&&this._onRecordingStatusUpdate!=null){this._disablePolling();this._pollingLoop();}}},{key:\"_callOnRecordingStatusUpdateForNewStatus\",value:function _callOnRecordingStatusUpdateForNewStatus(status){if(this._onRecordingStatusUpdate!=null){this._onRecordingStatusUpdate(status);}}},{key:\"_performOperationAndHandleStatusAsync\",value:function _performOperationAndHandleStatusAsync(operation){var status;return _regeneratorRuntime.async(function _performOperationAndHandleStatusAsync$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:throwIfAudioIsDisabled();if(!this._canRecord){_context6.next=9;break;}_context6.next=4;return _regeneratorRuntime.awrap(operation());case 4:status=_context6.sent;this._callOnRecordingStatusUpdateForNewStatus(status);return _context6.abrupt(\"return\",status);case 9:throw new Error('Cannot complete operation because this recorder is not ready to record.');case 10:case\"end\":return _context6.stop();}}},null,this,null,Promise);}},{key:\"setOnRecordingStatusUpdate\",value:function setOnRecordingStatusUpdate(onRecordingStatusUpdate){this._onRecordingStatusUpdate=onRecordingStatusUpdate;if(onRecordingStatusUpdate==null){this._disablePolling();}else{this._enablePollingIfNecessaryAndPossible();}this.getStatusAsync();}},{key:\"setProgressUpdateInterval\",value:function setProgressUpdateInterval(progressUpdateIntervalMillis){this._progressUpdateIntervalMillis=progressUpdateIntervalMillis;this.getStatusAsync();}},{key:\"prepareToRecordAsync\",value:function prepareToRecordAsync(){var options,extensionRegex,_await$ExponentAV$pre,uri,status,currentStatus,_args7=arguments;return _regeneratorRuntime.async(function prepareToRecordAsync$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:options=_args7.length>0&&_args7[0]!==undefined?_args7[0]:RECORDING_OPTIONS_PRESET_LOW_QUALITY;throwIfAudioIsDisabled();if(!_recorderExists){_context7.next=4;break;}throw new Error('Only one Recording object can be prepared at a given time.');case 4:if(!this._isDoneRecording){_context7.next=6;break;}throw new Error('This Recording object is done recording; you must make a new one.');case 6:if(!(!options||!options.android||!options.ios)){_context7.next=8;break;}throw new Error('You must provide recording options for android and ios in order to prepare to record.');case 8:extensionRegex=/^\\.\\w+$/;if(!(!options.android.extension||!options.ios.extension||!extensionRegex.test(options.android.extension)||!extensionRegex.test(options.ios.extension))){_context7.next=11;break;}throw new Error(\"Your file extensions must match \"+extensionRegex.toString()+\".\");case 11:if(this._canRecord){_context7.next=28;break;}if(eventEmitter){this._subscription=eventEmitter.addListener('Expo.Recording.recorderUnloaded',this._cleanupForUnloadedRecorder);}_context7.next=15;return _regeneratorRuntime.awrap(ExponentAV.prepareAudioRecorder(options));case 15:_await$ExponentAV$pre=_context7.sent;uri=_await$ExponentAV$pre.uri;status=_await$ExponentAV$pre.status;_recorderExists=true;this._uri=uri;this._options=options;this._canRecord=true;currentStatus=_objectSpread(_objectSpread({},status),{},{canRecord:true});this._callOnRecordingStatusUpdateForNewStatus(currentStatus);this._enablePollingIfNecessaryAndPossible();return _context7.abrupt(\"return\",currentStatus);case 28:throw new Error('This Recording object is already prepared to record.');case 29:case\"end\":return _context7.stop();}}},null,this,null,Promise);}},{key:\"startAsync\",value:function startAsync(){return _regeneratorRuntime.async(function startAsync$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:return _context8.abrupt(\"return\",this._performOperationAndHandleStatusAsync(function(){return ExponentAV.startAudioRecording();}));case 1:case\"end\":return _context8.stop();}}},null,this,null,Promise);}},{key:\"pauseAsync\",value:function pauseAsync(){return _regeneratorRuntime.async(function pauseAsync$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:return _context9.abrupt(\"return\",this._performOperationAndHandleStatusAsync(function(){return ExponentAV.pauseAudioRecording();}));case 1:case\"end\":return _context9.stop();}}},null,this,null,Promise);}},{key:\"stopAndUnloadAsync\",value:function stopAndUnloadAsync(){var _stopResult;var stopResult,stopError,status;return _regeneratorRuntime.async(function stopAndUnloadAsync$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:if(this._canRecord){_context10.next=6;break;}if(!this._isDoneRecording){_context10.next=5;break;}throw new Error('Cannot unload a Recording that has already been unloaded.');case 5:throw new Error('Cannot unload a Recording that has not been prepared.');case 6:_context10.prev=6;_context10.next=9;return _regeneratorRuntime.awrap(ExponentAV.stopAudioRecording());case 9:stopResult=_context10.sent;_context10.next=15;break;case 12:_context10.prev=12;_context10.t0=_context10[\"catch\"](6);stopError=_context10.t0;case 15:if(Platform.OS==='web'&&((_stopResult=stopResult)==null?void 0:_stopResult.uri)!==undefined){this._uri=stopResult.uri;}_context10.next=18;return _regeneratorRuntime.awrap(ExponentAV.unloadAudioRecorder());case 18:_context10.next=20;return _regeneratorRuntime.awrap(this._cleanupForUnloadedRecorder(stopResult));case 20:status=_context10.sent;return _context10.abrupt(\"return\",stopError?Promise.reject(stopError):status);case 22:case\"end\":return _context10.stop();}}},null,this,[[6,12]],Promise);}},{key:\"getURI\",value:function getURI(){return this._uri;}},{key:\"createNewLoadedSound\",value:function createNewLoadedSound(){var initialStatus,onPlaybackStatusUpdate,_args11=arguments;return _regeneratorRuntime.async(function createNewLoadedSound$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:initialStatus=_args11.length>0&&_args11[0]!==undefined?_args11[0]:{};onPlaybackStatusUpdate=_args11.length>1&&_args11[1]!==undefined?_args11[1]:null;console.warn(\"createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name\");return _context11.abrupt(\"return\",this.createNewLoadedSoundAsync(initialStatus,onPlaybackStatusUpdate));case 4:case\"end\":return _context11.stop();}}},null,this,null,Promise);}},{key:\"createNewLoadedSoundAsync\",value:function createNewLoadedSoundAsync(){var initialStatus,onPlaybackStatusUpdate,_args12=arguments;return _regeneratorRuntime.async(function createNewLoadedSoundAsync$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:initialStatus=_args12.length>0&&_args12[0]!==undefined?_args12[0]:{};onPlaybackStatusUpdate=_args12.length>1&&_args12[1]!==undefined?_args12[1]:null;if(!(this._uri==null||!this._isDoneRecording)){_context12.next=4;break;}throw new Error('Cannot create sound when the Recording has not finished!');case 4:return _context12.abrupt(\"return\",Sound.createAsync({uri:this._uri},initialStatus,onPlaybackStatusUpdate,false));case 5:case\"end\":return _context12.stop();}}},null,this,null,Promise);}}]);return Recording;}();Recording.createAsync=function _callee4(){var options,onRecordingStatusUpdate,progressUpdateIntervalMillis,recording,status,_args13=arguments;return _regeneratorRuntime.async(function _callee4$(_context13){while(1){switch(_context13.prev=_context13.next){case 0:options=_args13.length>0&&_args13[0]!==undefined?_args13[0]:RECORDING_OPTIONS_PRESET_LOW_QUALITY;onRecordingStatusUpdate=_args13.length>1&&_args13[1]!==undefined?_args13[1]:null;progressUpdateIntervalMillis=_args13.length>2&&_args13[2]!==undefined?_args13[2]:null;recording=new Recording();if(progressUpdateIntervalMillis){recording._progressUpdateIntervalMillis=progressUpdateIntervalMillis;}recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);_context13.next=8;return _regeneratorRuntime.awrap(recording.prepareToRecordAsync(_objectSpread(_objectSpread({},options),{},{keepAudioActiveHint:true})));case 8:_context13.prev=8;_context13.next=11;return _regeneratorRuntime.awrap(recording.startAsync());case 11:status=_context13.sent;return _context13.abrupt(\"return\",{recording:recording,status:status});case 15:_context13.prev=15;_context13.t0=_context13[\"catch\"](8);recording.stopAndUnloadAsync();throw _context13.t0;case 19:case\"end\":return _context13.stop();}}},null,null,[[8,15]],Promise);};export*from\"./RecordingConstants\";export{PermissionStatus};","map":{"version":3,"sources":["../../src/Audio/Recording.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  Platform,\n} from 'expo-modules-core';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n} from '../AV';\nimport ExponentAV from '../ExponentAV';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport { RecordingOptions, RecordingStatus } from './Recording.types';\nimport { RECORDING_OPTIONS_PRESET_LOW_QUALITY } from './RecordingConstants';\nimport { Sound } from './Sound';\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.getPermissionsAsync();\n}\n\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.requestPermissionsAsync();\n}\n\n/**\n * Check or request permissions to record audio.\n * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Audio.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync,\n});\n\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus?: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    this._finalDurationMillis = finalStatus?.durationMillis ?? 0;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch (error) {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  // Note that all calls automatically call onRecordingStatusUpdate as a side effect.\n\n  static createAsync = async (\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY,\n    onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null,\n    progressUpdateIntervalMillis: number | null = null\n  ): Promise<{ recording: Recording; status: RecordingStatus }> => {\n    const recording: Recording = new Recording();\n    if (progressUpdateIntervalMillis) {\n      recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    }\n    recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n    await recording.prepareToRecordAsync({\n      ...options,\n      keepAudioActiveHint: true,\n    });\n    try {\n      const status = await recording.startAsync();\n      return { recording, status };\n    } catch (err) {\n      recording.stopAndUnloadAsync();\n      throw err;\n    }\n  };\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  async prepareToRecordAsync(\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string | null;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    let stopResult: RecordingStatus | undefined;\n    let stopError: Error | undefined;\n    try {\n      stopResult = await ExponentAV.stopAudioRecording();\n    } catch (err) {\n      stopError = err;\n    }\n\n    // Web has to return the URI at the end of recording, so needs a little destructuring\n    if (Platform.OS === 'web' && stopResult?.uri !== undefined) {\n      this._uri = stopResult.uri;\n    }\n\n    // Clean-up and return status\n    await ExponentAV.unloadAudioRecorder();\n    const status = await this._cleanupForUnloadedRecorder(stopResult);\n    return stopError ? Promise.reject(stopError) : status;\n  }\n\n  // Read API\n\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  /** @deprecated Use `createNewLoadedSoundAsync()` instead */\n  async createNewLoadedSound(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: AVPlaybackStatus }> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  async createNewLoadedSoundAsync(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: AVPlaybackStatus }> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n\nexport * from './RecordingConstants';\n\nexport {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  RecordingOptions,\n  RecordingStatus,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}